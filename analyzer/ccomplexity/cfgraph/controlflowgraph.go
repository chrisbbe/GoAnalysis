package cfgraph

import (
	"fmt"
	"github.com/chrisbbe/GoAnalysis/analyzer/ccomplexity/bblock"
	"github.com/chrisbbe/GoAnalysis/analyzer/ccomplexity/graph"
	"github.com/chrisbbe/GoAnalysis/analyzer/globalvars"
	"io"
	"os"
	"time"
	"bytes"
	"os/exec"
)

type ControlFlowGraph struct {
	*graph.Graph
}

func New() *ControlFlowGraph {
	return &ControlFlowGraph{graph.NewGraph()}
}

func (controlFlowGraph ControlFlowGraph) Draw(name string) error {
	dottyFile, err := os.Create(name + ".dot")
	if err != nil {
		return err
	}
	defer dottyFile.Close()

	var content bytes.Buffer

	// Write header information.
	content.WriteString("/* --------------------------------------------------- */\n")
	content.WriteString(fmt.Sprintf("/* Generated by %s\n", globalvars.PROGRAM_NAME))
	content.WriteString(fmt.Sprintf("/* Version: %s\n", globalvars.VERSION))
	content.WriteString(fmt.Sprintf("/* Website: %s\n", globalvars.WEBSITE))
	content.WriteString(fmt.Sprintf("/* Date: %s\n", time.Now().String()))
	content.WriteString("/* --------------------------------------------------- */\n")

	// Start writing the graph.
	content.WriteString("digraph AST {\n")
	for _, node := range controlFlowGraph.Nodes {
		for _, outNode := range node.GetOutNodes() {
			content.WriteString(fmt.Sprintf("\t\"%s\" -> \"%s\";\n", node, outNode))
		}
	}
	content.WriteString("}\n")

	if _, err := io.WriteString(dottyFile, content.String()); err != nil {
		return err
	}
	cmd := exec.Command("dot", "-Tpdf", dottyFile.Name(), "-o", name + ".pdf")
	return cmd.Run()
}

// GetControlFlowGraph generates the control flow ccomplexity.graph for each function or
// method found in the sequence of basic-blocks. Returning an array of control
// flow graphs where each entry represents an function or method.
func GetControlFlowGraph(basicBlocks []*bblock.BasicBlock) (cfg []*ControlFlowGraph) {
	prevFunctionBlockIndex := -1 // -1 indicates that no FUNCTION_ENTRY has been found.

	//Slicing up basic-blocks containing function or method.
	for index, basicBlock := range basicBlocks {
		if basicBlock.Type == bblock.FUNCTION_ENTRY && prevFunctionBlockIndex == -1 {
			prevFunctionBlockIndex = index //FUNCTION_ENTRY detected, set index.
		} else if basicBlock.Type == bblock.FUNCTION_ENTRY {
			cfg = append(cfg, getControlFlowGraph(basicBlocks[prevFunctionBlockIndex:index]))
			prevFunctionBlockIndex = index // Track which block was the last FUNCTION_ENTRY block.
		}
	}
	cfg = append(cfg, getControlFlowGraph(basicBlocks[prevFunctionBlockIndex:len(basicBlocks)])) //
	return cfg
}

// getControlFlowGraph generates and returns the control-flow ccomplexity.graph based on the array of basic blocks.
func getControlFlowGraph(basicBlocks []*bblock.BasicBlock) *ControlFlowGraph {
	//controlFlowGraph := graph.NewGraph()
	//var controlFlowGraph ControlFlowGraph
	controlFlowGraph := New()
	var lastBlockAdded *bblock.BasicBlock

	for _, basicBlock := range basicBlocks {
		lastBlockAdded = basicBlock

		for _, successorBlock := range basicBlock.GetSuccessorBlocks() {
			controlFlowGraph.InsertEdge(&graph.Node{Value: basicBlock}, &graph.Node{Value: successorBlock})
			lastBlockAdded = successorBlock
		}
	}

	startNode := &graph.Node{Value: bblock.NewBasicBlock(-1, bblock.START, 0)}
	exitNode := &graph.Node{Value: bblock.NewBasicBlock(-1, bblock.EXIT, 0)}
	controlFlowGraph.InsertEdge(startNode, controlFlowGraph.Root)
	controlFlowGraph.InsertEdge(&graph.Node{Value: lastBlockAdded}, exitNode)

	return controlFlowGraph
}
